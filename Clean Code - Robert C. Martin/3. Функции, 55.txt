Функции (методы) не должны быть большими. Не больше 20 строк.
Методы должны быть компактными, чтобы пользователь одним взглядом мог понять, что она делает. (не больше 20-ти строк)
Если в функции много строк, то заключите эти строки в отдельную функцию.
if, else и  while должны состоять из одной строки.
В if - else - while - вложенность не больше двух.
Функция должны выполнять только одну операцию. Она должна выполнять её хорошо. И ничего другого она делать не должна.
Функция должна выполнять только одну операцию. Она должна выполнять её хорошо. И ничего другого она делать не должна.
Все команды функции должны находиться на одном уровне абстракции. (стр. 61 - пока непонятно)
создать html)
Функцию, выполняющую одну операцию невозможно разделить на секции.
Одна операция - если действия на одном уровне абстракции (проверить или страница тестовая; добавить хедер; 
Код должен читаться сверху вниз. То есть верхняя функция А состоит из подфунции Б. Затем идёт расшифровка функции Б, которая в свою очередь состоит из подфункции В. Дальше идёт расшифровка функции В... и так далее.
Чтение кода должно идти вниз. Где под функцией располгаются внутренние функции.
!Стр. 62 - пока непонятно.
Давайте имя функции такое, что она выполняет. Не бойтесь длинных имён.
У функций должно быть максимум два аргумента. (когда много аргументов - много вариантов для тестрования)
Три вида функции с одним аргументом:
 - проверка условия, связанного с аргументом: boolean fileExists("MyFile");
 - обработка аргумента, его преобразование и возвращение: InputStream fileOpen("MyFile");
 - событие - программа использует аргумент для изменения состояния системы: void passwordAttemptFailedNtimes("int attempts");
Используйте StringBuffer transform(StringBuffer in) вместо vaid transform(StringBuffer out).
Если в аргументе булевская переменная, то это означает, что функция выполняет две операции (в зависиомтси от ложь-правда). Вместо render(boolean isSuite) надо разбить на две: renderForSuite() и renderForSingleTest().
Стр. 66 не понял. Старайтесь проебразовать функции с двумя аргуменами в унарные.
Старайтесь не использовать тренарные функции.
Если есть два или три аргумента, то можно упаковать их в отдельный класс:
    Circle makeCircle(double x, double y, double radius);
    Circle makeCircle(Point center, double radius);
Функции с переменным значнием аргументов воспринимаются как унарные, если переменные одного типа: void monad(Integer... args).
Фунция должна быть глаголом, а аргументы - существительными: writeField(name); assertExpectedEqualsActual(expected, actual);
Функция должны выполнять только одну операцию. Если внутри есть скрытая операция, то это плохо. Напр. стр. 69 - в функции мы проверяем пароль, и ещё создаём сессию. А если захочется просто проверить пароль, то возникнут проблемы с существующей сессией.
Если аргументом функции является то, что бедут изменено, то это плохо. Напр. public void appendFooter(StringBuffer report) - здесь стрингбуфферу репорт добавится футер. А надо, чтобы у самого объекта была функция, которая добалвяет ему футер: report.appendFooter();
Функция должна либо изменять состояние объекта, либо возвращать информацию об этом объекте. (см. стр. 70-71)
Вместо возвращения кодов ошибок используйте try catch.
Блоки try-catch усложняют чтение кода, поэтому выносите их в отдельные функции. (72)
Стр. 73 - не понял.
Применяйте принцип DRY - don't repeat yourself. Код не должен повторяться.
Структурное программирование - когда в функции есть только одна точка входа и одна точка выхода. То есть только один return. И нет break и continue.
Как писать функции? Сначала пишете грязную. А потом постепенно причёсываете, согласно описанным правилам. При этом надо следить, чтобы выполнялись все тесты.
Опытные программисты рассматривают систему как историю, которую они должны рассказать, а не как программу, которую нужно написать.
-
[стр. 56]
Если два одинковых if - выносите в булевскую переменную.
Если в функции много строк - разбейте на логические блоки, и вместо окаждого блока создайте private функцию, название которой точно описывает, что в ней происходит.
Функции должны быть компактны.
Не больше 20-ти строк.
Делайте из большой функции матрёшку с вложенными функциями. Но каждая вложенная должна описывать, что она делает. А реализация уже на самом нижнем уровне.
Если используете if - вложенность не больше двух.
Внутри if - минимальное количество строк. В идеале - вызов подфункции.
Функция должна выполнять только одну операцию. Она должна выполнять её хорошо. И ничего другого она делать не должна.
Одна операция - это когда все действия на одном уровне абстракции (важная концепция; второстепенная подробность). В примере: проверяем, является ли страница тестовой, включаем в неё начальные и кнечные блоки, генерируем код html.
Функция, выполняющая только одну операцию, невозможно осмысленно разделить на блоки [стр. 98].
Чтение кода сверху вниз: правило понижения.
В главной функции - подфункции с одним уровнем абстракции. Читается последовательно как книга.
А когда заходим в подфункцию - эта история повторяется [стр. 76]. 
Switch. [стр. 63]
А если типовemployee много, то после каждого добавления типа нужно изменять switch.
Плюс функций, которые зависят от типа employee тоже может быть много.
Поэтомы мы сощдаем фабрику с одним методом, который возвращает объект нужного типа и методы, которые зависят от типа, уже прописаны в подклассе [стр. 63].
Для названий функции не бойтесь использовать длинные имена. Главное, чтобы прочтя название функции уже было понятно, что она делает.
Из этого следует:
  принцип единоответсвенност (если метод выполняет одну функцию, то легче назвать)
  маленькие методы (меньше метод - легче назвать)
Аргументов метода может быть максимум три.
Если больше:
  создавайте новый объект с 4-мя филдами и передавайте этот объект в качестве аргумента
  в класс, в котором находится вызываемый метод, добавляйте филды. И эти филды инициализируйте в доп методе типа setup() (или в конструкторе) [стр. 76 - SetupTeardownIncluder(PageData pageData)]
Если аргументов много - придётся писать тесты для всех комбинаций, что неудобно.
Старайтесь возвращать сколькулированное значение в ретёрне, а не во входящих аргументах.
Если аргумент булевский, это значит что метод выполняет две операции (при истине и при лжи). Что плохо.
Можно использовать много аргументов если method(Object... args), напр. String.format()
Когда создаете имя метода, помните и об аргументах. Название глагол, аргументы - существительное. К глаголу можно добавить доп сущ-е, чтобы раскрыть аргумент. writeField(String name)
Когда создаете и даете название функции, есть опасность, что она выполняет действия, которые не описаны: побочный эффект. В функции checkPassword() происходит инициализация сессии, что не описано.
Избегайте функций, параметры которых будут изменены и отданы наружу: public void appendFooter(StringBuffer report) - здесь к репорту будует добавлен футер.
Пусть функция меняет состояние своего владельца: report.appendFooter().
Функция должна что-то делать или отвечать на какой-то вопрос, но не одновременно.
Когда функция возвращает код ошибки (ок не ок), то нужно громозить ифы и элзы. [стр. 71]
Лучше испольщовать исключения.
В блоке try если много когда - лучше вынести в отдельную функцию [стр. 72].
Избегайте дублирования. Если видите повторяющийся код - создавайте функцию, которая будет использована в двух местах.
Многие типы программирования и были созданы, чтобы избежать дублирования.
Эдгар Дейкстра считает, что у функции может быть только один return. Но автор говорит, что можно использовать много, если так лучше будет читаться код.
Автор сначала пишет грязный код. Потом пишет тесты. А потом причесывает согдано своей книги, да так, чтобы тесты проходили. И в итоге у него чистый код.