 - Предисловие, 14 -

Честность в мелочах - вовсе не мелочь.
Программирование похоже на строительство. А программа - на архитектуру. В ней важны мелочи.
А также похоже на автомобилестроение. Нужны качества: сосредоточенность, присутствие духа, мышление. А также японская философия 5S (стр. 15)
А также метод TPM - когда машины строятся так, чтобы их легко можно сопровождать, то есть заменять расходники. Код тоже надо писать так, чтобы раз в семь лет большие блоки переписывать заново. А маленькие - раз в неделю.
Японские методы не новы - они есть в наших пословицах. Надо содержать всё в чистоте, чтобы не было беспорядка. Вещи должны лежать аккуратно. Обращать внимание на мелочи. Не надо откладывать на потом (если есть плохой код - его нужно переработать сразу же). Делай маленькие дела, зато их сумма будет большая.
Принцип постоянного совершенствования.
Нам нравится глобальное. Лишь бы код работал, а как он написан внутри - мы не любим обращать внимание (напр. на отступы). В Японии большое значение имеет рабочий. Он должен выполнять работу идеально, и из маленьких идеальных кусочков создаются великие продукты.
Надо быть честным перед самим собой за состояние своего кода.
Человеку свойственно ошибаться, небесам свойственно прощать.


 - Введение, 20 -

Качественный код - это минимальное количество ошибок. Для этого нужно быть профессионалом - а это - знания и практический опыт. Вы должны знать принцыпы, паттерны, приёмы и эврестические правила и втереть их в пальцы.
Чтобы научитсья кататься на велосипеде, надо много раз упасть. Уметь писать чистый код - тяжелая работы. Над кодом необходимо попотеть.
Книга - не просто так прачитать. С ней придётся работать и кодить.
Книга построена так, что идёт пример кода - а затем контекст, номер эврестического правила.
-
Как писать, в котором будет мало 'Какого чёрта': профессионализм.
Профессионализм - это знания, и приктический опыт. Знания на кончиках пальцев.
Писать чистый код - тяжелая работа. Нужно попотеть. Неободимо пытаться и тепреть неудачи.
Нужно прочитать все три части.
Есть ссылки на эврестическое правило: [H22].


 - 1. Чистый код, 23 -

Код никогда не исчезнет.
Однажды одна компания написала приложение, которое использовали многие компани. Но код был плохой. В итоге стали появляться ошибки и компания разорилась.
Мы пишем плохой код по разным причинам. А потом когда возвращаемся, не можем пробраться через его гущи. Мы обещаем вернуться к плохому коду и почистить его завтра. Но есть закон Лнблана: потом равносильно никогда.
Когда начинаем проект, то сначала он идёт быстро. Но через год, когда вносятся дополнения и изменения, нарушается работа в трёх местах и исправления двигаются со скоростью улитки. Производительность приближается к нулю.
А потом начальство принимает решение, чтобы переписать приложение заново с нуля. Иногда это длится долго и иногда история повторяется, когда в новой версии такой же непонятный плохой код.
Ва наверное часто приходилось видеть, как вместо того, чтобы сделать изменение в одном месте, эти изменения нужно вносить во всей программе.
Если код плохой, то мы можем винить кого угодно: начальство, сроки, маркетологов и так далее. Но только мы ответсвенны за чистый код.
Начальники хотят защищать сроки, а вы должны защищать свой код. Начальники хотят слышать правду. (Например пациент говорит врачу не мыть руки, чтобы было быстрее, но вы врач - и вы должны их мыть, чтобы было лучше.)
Профессионалы знают: чтобы выдерживать график, нужно заботиться о чистом коде.
Чистый код - это как искусствоо. Кому то дано. А другим нужно применять все правила, которые вы изучите. Профи должен не только посмотреть на код и сказать, что он грязный, но и знать, что надо делать.
Бьёрн Страуструп: чистый код - элегантный. То есть сочетает простоту и изобретательность, доставляющий удовольствие.
Грязный код - это как принцып разбитых окон.
Хороший код - каждый класс, каждый модуль решает только одну задачу.
Грэди Буч: чистый код - удобочитаемый, как хорошая проза.
Дэйв Томас: чистый код удобно читать и дорабатывать другим людям. Должны быть тесты.
Майкл Физерс: чистый код - это код, над которым автор тщательно поработал, вы не сможете его улучшить.
Рон Джеффрис: чистый код: проходит все тесты; не содержит дубликатов; выражает все концепции проектирования, заложенные в систему; содержит минимальное количество сущностей - классов, методов, функций и т.д. Объект или метод должен выполнять только одну в функцию, в противном случае его надо дробить. Ещё он любит абстракции
Уорд Каннингем: чистый код делает то, что вы ожидали.
Автор говорит, что эта книга - плод усилий многих людей, на протяжении многих лет. Поэтому можете смело применять советы.
На самом деле вы чаще читаем свой старый код, чем пишем новый, поэтмоу чистота кода очень важна.
Правило бойскаута: оставь место стоянки чище, чем оно было до твоего прихода. То есть написать чистый код недостаточно. Нужно поддерживать его во времени. А когда вы встретите плохой код - то сделайте его чище.
После прочтения этой книги автор рекомендует книгу "Agile Software Development: Principles, Patterns, and Practices." 
-
Мы будем рассматривать код сверху вниз, снизу вверх и даже изнутри. Вы узнаете как писать хороший код.
Говорят, что код ичсезнет. Менеджеры будут просто говорить требования, а машины их выполнять. Но код не исчезнет, потому что требования должны быть очень точные, с многими нюансами. И сам человек не в состоянии чётко сформулировать требования. Код - это язык, на котором выражаются потребности.
Хороший код очень важен. Был хороший продукт. Но с скаждой ново версией он становился всё хуже. Потому что был на писан на плохом коде. Компания разорилась.
Каждый из нас видел, что код плохой, но он работает. И откладывал рефакторинг на потом. Закон Леблана: потом равносильно никогда.
Плохой код - это когда делаешь изменение в одном месте, а оно затрагивает три других. Когда тратишь много времени, чтобы понять хитросплетения кода. И чтобы пофиксить что-то или добавить - ещё больше увеличиваешь хитросплетения.
А ещё спешишь успеть к релизу - становится только хуже. Но об этом узнаешь на следующих релизах.
Был случай, когда нужно было переделать с нуля плохой старый код. И компания параллельно поддерживала старый и разрабатывала новый 10 лет. Это плата за плохой код и за непрофессионализм.
За плохой код вина лежит только на нас самих, а не на требованиях заказчика или сроках. Дело в нашем профессионализме.
Маркетологи обращаются к нам за требованиями. Директора - за сроками.
Директора защищают графики, а вы должны защищать свой код. И говорить директору правду.
Единственный способ работать быстро и выдерживать график - постоянно поддерживать чистоту в коде.
Чтобы написать чистый код, необходимо применять множетво приемов, используя чувство 'чистоты', чувство 'кода'. Его можно развить.
Программист, пишущий чистый код - это ходожник, который приводит пустой экран в элегантно запрограммированную систему.
Что такое чистый код?
Бьёрн Страуструп (создатель c++). Код должен быть элегантнам, то есть приятно читать. Зависимости минимльны. Логика прямолинейной. Полня обработка ошибок. Уделять внимание мелочам. Решает одну задачу.
Дэйв Томас и Энди Хант ('Программист-прагматик'). Плохой код - как разбитые окна.
Грэди Буч. Чистый код прост и прямолинеен. Читается как проза. Содержит только то, что необъодимо.
Дэйв Томас. Хорошо читать и дорабатывать. Есть тесты. Минимальные зависимости.
Майкл Физерс. Код выглядит так, словно автор над ним тщательно потрудился. Вы не найдёте улучшений.
Рон Джеффрис. Проходит все тесты. Не содержит дубликатов. Выражает все концепции, заложенные в систему. Содержательность имён. Содержит минимальное количество сущностей. Разделение большого метода, на один с подметодами. Раннее построение абстракиций.Можно искать элемент в массиве, в листе, мапе: я выношу это в абстрактный метод; в будущем реализацию можно будет поменять.
Уорд Каннингем. Если каждая функция делает то, что вы ожидали.
Роберт Мартин. Считайте эту книгу - правилами мастеров, которые сами применяют правила чистого кода. Рекомендации являются плодами десятилетий размышлений, проб и оишбок.
На самом деле мы читам много кода. Поэтому код должен хорошо читаться.
Оставляйте код чище, чем он был до нашего прихода.
Перекликается с другой книгой: принципы, паттерны и практики.
Принцип единой отвественности (SRP), принцып открытости/закрытости (OCP), принцип обращения зависимостей (DIP).
Книга обещает сделать из вас хорошего программиста. Она показывает в каком напрвлении мыслят хорошие программисты и какие приемы и инструменты они применяют.


 - 2. Содержательные имена, 39 -

Имя перемнной должно отображать, что именно хочет программист. Они должны быть содержательными.
int d; // прошедшее время - это плохо, а надо
int elapsedTimeInDays;
Не называйте имена перемнных очень популярными словами. Например linux...
Не сохдавайте имена очень похожие, которые отдичаюстя на одну букву и их можно спутать.
Не используйте буквы L и O.
Не делайте так: user1, user2...
Не делайте zork, theZork...
Не делайте Product, ProductInfo, ProductData...
Не используйте зарезервированные имена: variable, table, NameString, CustomerObject.
Используйте слова, котореы удобно произносить.
Правильные имена удобно искать поисковиком.
Короткие имена используйте только для локальных переменных в маленьких методах.
Вместо цифр используйте константы с нормальным названием.
В именах перемнных не надо кодировать их типы и область видимости.
Не используйте в полях класса префикс m_, как было раньше.
В начале интерфейсов не используйте префикс I. (IShapeFactory)
Не давайте имена из одной буквы, если её можно заменить нормальным словом.
Имя класса и объектов должно быть существительным. Не используйте такие слова как Manager, Processor, Data или Info.
Имена методов - глаголы.
В именах методов используйте предикаты get, set и is.
Используйте конструкторы, для создания объектов с аргуменатми (поля класса).
В именах не используйте шутки, крылатые выражения и остроумие.
Выберите одну концепцию и используйте её на всём приложении. (Например get - и везде; или find - и везде) (Например: controller, manager, driver - выбирайте одно из трёх)
Не используйте одно слово, у которого есть разные значения, а разных случаях. (Например add и слова insert и append)
Псипользуйте мена из мира информатики и математики.
В коде, ориентированном на концепции из пространства задач, следует использовать имена из пространства задач.
Старайтесь, чтобы переменные вписывались в контекст. То есть создавая переменные firstName, lastName, street, state, zipCode, они должны быть полями класса Address, чтобы было единогласно понятно, что они относятся к адресу. (стр. 51)
Не включайте избыточный контекст. (То есть не надо писать addressStreet, addressCity и так далее)
Не бойтесь переименовывать, чтобы улучшить код, даже если другие против. 
-
Имена должны передавать намерения программиста. Вместо int d -> int elapsedTimeInDays; daysSinceCreation.
Не используйте именна, у которых есть твёрдый ассоциации. Вместо accountList -> accounts; bunchOfAccounts
Не используйте имена, которые очень похожи и можно попутать.
Старайтесь чтобы новый программист мог понять предназначение класса по его имени, не заглядывая в description (для выбора из выпадающего списка).
Не используйте L и O в перемнных (похожи на 1 и 0).
Если два похожих объекта. Один назван правильно, а второй рандомно (неинформативное название), лишь бы не совпадало (например с ошибкой) - плохой подход: например class и klass; productInfo и productData
Называть a1, a2, ... aN - плохой подход. Лучше source и destination.
Избыточные слова - плохой подход: слово variable в названии переменной; слово table в имени таблицы; nameString -> name; customerInfo -> customer; accountData -> account; theMessage -> message
В названиях не ипользуйте сокращения и аббревиатуры. genymdhms -> generationTimestamp
Выбирайте имена удобные для поиска. int i = 5 -> int WORK_DAYS_PER_WEEK = 5. Int i используйте в локальных методах.
Не кодируйте в именах тип объекта и область видимости.
Не используйте префиксов. IShapeFactory - ShapeFactory -> ShapeFactory - ShapeFactoryImpl
Не создавайте однобуквенных имён, типа и так понятно, что это означает. String r -> Syting lowerCaseUrl
Имя класса (объекта) - сущетсвительное. Избугайте Manager, Processor, Data, Info.
Имея метода - глагол (postPayment, daletePage). Можно начинать с get, set, is.
Если много перегруженных конструкторов: Complex fulcrumPoint = new Complex(23.0) -> Complex fulcrumPoint = Complex.fromRealNumber(23.0). Соответсвующие конструкторы должны быть private.
Не используйте жаргон или шутки.
Выберите один лексикон для всей программы: fetch или retrieve или get; controller или manager или driver.
Не используйте одно слово для разных функциональностей. Если есть add, то можно ещё использовать insert, append.
Можете присваивать имена из мира информатики (не только бизнес логики): AccountVisitor, JobQueue. Имена из пространства решения.
Также имена из пространства задачи.
Названия могут полностью описывать суть. Но можно добавить в контекст: addressCity, addressStreet -> class Address с полями city, stree. Если есть метод, в котором три переменные, из которых генерится message; то лучше создать класс Message, и тогда эти три перемнные будут в контексте и понятно для чего они служат [51].
Не добавляйте избыточный контекст. AccountAddress -> Address accountAddress = new Address()
Не бойтесь переименовывать существующий код.
-
Время, потраченное на придумывание имени, окупится. Изменяйте имя, если найдете лучшие варианты.
Имя переменной должно сообщить почему эта переменная существует, что она делает и как используется.
Если после переменной есть комментарий, занчит она не передает намерений программиста.\
ind d; -> int daysSinceCreation
[стр. 41]
Если массивы и листы - называйте их как сущности, и элементы тоже.
Вместо if (cell[STATUS_VALUE] == FLAGGED), создайте класс, в котором хранится int[] cells и используйте внутренний boolean метод:
if (cell.isFlagged())
Не используйте сокращения и аббревиатуры.
В длинных названиях не делайте два очень похожих.
Вместо accountList -> accounts.
Другой разработчки будет выбирать класс по имени из списка в IDE.
Буквы l и O очень похожи на 1 и 0.
Старайтесь избегать: variable1, variable2 ...
Используетй: source, target.
Избегайте неинформатичных названий: ProductData и ProductInfo.
moneyAmount -> money or amount
customerInfo -> customer
accountData -> account
Если есть перемнная product не называйте вторую theProduct.
Не делайте масло масленное:
не используйте variable в именах переменных (и так понятно, что перемнная)
не используйте table в именах таблиц
не используйте List в именах списков
и т.д.
Не используйте сокращения и аббревиатуры. Названия удобопроизносимые.
Вместо dmy (day-month-year) -> timestamp.
Нормальные имена хороши тем, что их хорошо искать в коде.
Используйте константы вместо цифр.
Длина имени должна сщщтветсвовать размеру его области видимости [N5].
Короткое имя - только для локальных переменных.
Не кодируйте на названии тип объекта.
PhoneNumber phoneString - плохо.
Не называйте интерфейсы в старом стиле: IShapeFactory. Просто ShapeFactory. Реализация: ShapeFactoryImpl.
Имя класса - существительное.
Старайтесь избегать: Manager, Processor, Data, Info.
Имя метода - глагол.
Плюс можно использовать get, set, is.
Исрользуйте билдеры вместо конструкторов с параметрами.
Не используйте шутки и отсылки, известные только вам.
Выберите одно слово для каждой концепции:
fetch, retrieve, get
controller, manager, driver
DeviceManager, ProtocolController
Не используйте слова, у которых много значений (напр. add):
добавить объект в существуюйщий список - add
добавить объект в пустой список - insert
добавить слово в конец предложения - append
  вместо везде add
Не бойтесь присваивать технические имена. Например AccountVisitor, потому что есть паттерн visitor. (имена из простарнства решения)
Именя из пространства задачи - это названия объектов требований.
Используйте контекст когда даёте имена.
Если в коде два раза state. То один переименуйте в addressState, а второй в taxState.
А лучше создайте класс Address.
Когда в методе много переменных - сложите их в отдельный класс, и в классе создайте метод, который управляет этими перемнными (инкапсуляция)
[стр. 51]
Не используйте избыточный контекст. Класс Address а экземпляры accountAddress и customerAddress.
Разные адреса: PostalAddress, MacAddress, UrlAddress - можно.


 - 3. Функции, 55 -

Функции (методы) не должны быть большими. Не больше 20 строк.
Методы должны быть компактными, чтобы пользователь одним взглядом мог понять, что она делает. (не больше 20-ти строк)
Если в функции много строк, то заключите эти строки в отдельную функцию.
if, else и  while должны состоять из одной строки.
В if - else - while - вложенность не больше двух.
Функция должны выполнять только одну операцию. Она должна выполнять её хорошо. И ничего другого она делать не должна.
Функция должна выполнять только одну операцию. Она должна выполнять её хорошо. И ничего другого она делать не должна.
Все команды функции должны находиться на одном уровне абстракции. (стр. 61 - пока непонятно)
создать html)
Функцию, выполняющую одну операцию невозможно разделить на секции.
Одна операция - если действия на одном уровне абстракции (проверить или страница тестовая; добавить хедер; 
Код должен читаться сверху вниз. То есть верхняя функция А состоит из подфунции Б. Затем идёт расшифровка функции Б, которая в свою очередь состоит из подфункции В. Дальше идёт расшифровка функции В... и так далее.
Чтение кода должно идти вниз. Где под функцией располгаются внутренние функции.
!Стр. 62 - пока непонятно.
Давайте имя функции такое, что она выполняет. Не бойтесь длинных имён.
У функций должно быть максимум два аргумента. (когда много аргументов - много вариантов для тестрования)
Три вида функции с одним аргументом:
 - проверка условия, связанного с аргументом: boolean fileExists("MyFile");
 - обработка аргумента, его преобразование и возвращение: InputStream fileOpen("MyFile");
 - событие - программа использует аргумент для изменения состояния системы: void passwordAttemptFailedNtimes("int attempts");
Используйте StringBuffer transform(StringBuffer in) вместо vaid transform(StringBuffer out).
Если в аргументе булевская переменная, то это означает, что функция выполняет две операции (в зависиомтси от ложь-правда). Вместо render(boolean isSuite) надо разбить на две: renderForSuite() и renderForSingleTest().
Стр. 66 не понял. Старайтесь проебразовать функции с двумя аргуменами в унарные.
Старайтесь не использовать тренарные функции.
Если есть два или три аргумента, то можно упаковать их в отдельный класс:
    Circle makeCircle(double x, double y, double radius);
    Circle makeCircle(Point center, double radius);
Функции с переменным значнием аргументов воспринимаются как унарные, если переменные одного типа: void monad(Integer... args).
Фунция должна быть глаголом, а аргументы - существительными: writeField(name); assertExpectedEqualsActual(expected, actual);
Функция должны выполнять только одну операцию. Если внутри есть скрытая операция, то это плохо. Напр. стр. 69 - в функции мы проверяем пароль, и ещё создаём сессию. А если захочется просто проверить пароль, то возникнут проблемы с существующей сессией.
Если аргументом функции является то, что бедут изменено, то это плохо. Напр. public void appendFooter(StringBuffer report) - здесь стрингбуфферу репорт добавится футер. А надо, чтобы у самого объекта была функция, которая добалвяет ему футер: report.appendFooter();
Функция должна либо изменять состояние объекта, либо возвращать информацию об этом объекте. (см. стр. 70-71)
Вместо возвращения кодов ошибок используйте try catch.
Блоки try-catch усложняют чтение кода, поэтому выносите их в отдельные функции. (72)
Стр. 73 - не понял.
Применяйте принцип DRY - don't repeat yourself. Код не должен повторяться.
Структурное программирование - когда в функции есть только одна точка входа и одна точка выхода. То есть только один return. И нет break и continue.
Как писать функции? Сначала пишете грязную. А потом постепенно причёсываете, согласно описанным правилам. При этом надо следить, чтобы выполнялись все тесты.
Опытные программисты рассматривают систему как историю, которую они должны рассказать, а не как программу, которую нужно написать.
-
[стр. 56]
Если два одинковых if - выносите в булевскую переменную.
Если в функции много строк - разбейте на логические блоки, и вместо окаждого блока создайте private функцию, название которой точно описывает, что в ней происходит.
Функции должны быть компактны.
Не больше 20-ти строк.
Делайте из большой функции матрёшку с вложенными функциями. Но каждая вложенная должна описывать, что она делает. А реализация уже на самом нижнем уровне.
Если используете if - вложенность не больше двух.
Внутри if - минимальное количество строк. В идеале - вызов подфункции.
Функция должна выполнять только одну операцию. Она должна выполнять её хорошо. И ничего другого она делать не должна.
Одна операция - это когда все действия на одном уровне абстракции (важная концепция; второстепенная подробность). В примере: проверяем, является ли страница тестовой, включаем в неё начальные и кнечные блоки, генерируем код html.
Функция, выполняющая только одну операцию, невозможно осмысленно разделить на блоки [стр. 98].
Чтение кода сверху вниз: правило понижения.
В главной функции - подфункции с одним уровнем абстракции. Читается последовательно как книга.
А когда заходим в подфункцию - эта история повторяется [стр. 76]. 
Switch. [стр. 63]
А если типовemployee много, то после каждого добавления типа нужно изменять switch.
Плюс функций, которые зависят от типа employee тоже может быть много.
Поэтомы мы сощдаем фабрику с одним методом, который возвращает объект нужного типа и методы, которые зависят от типа, уже прописаны в подклассе [стр. 63].
Для названий функции не бойтесь использовать длинные имена. Главное, чтобы прочтя название функции уже было понятно, что она делает.
Из этого следует:
  принцип единоответсвенност (если метод выполняет одну функцию, то легче назвать)
  маленькие методы (меньше метод - легче назвать)
Аргументов метода может быть максимум три.
Если больше:
  создавайте новый объект с 4-мя филдами и передавайте этот объект в качестве аргумента
  в класс, в котором находится вызываемый метод, добавляйте филды. И эти филды инициализируйте в доп методе типа setup() (или в конструкторе) [стр. 76 - SetupTeardownIncluder(PageData pageData)]
Если аргументов много - придётся писать тесты для всех комбинаций, что неудобно.
Старайтесь возвращать сколькулированное значение в ретёрне, а не во входящих аргументах.
Если аргумент булевский, это значит что метод выполняет две операции (при истине и при лжи). Что плохо.
Можно использовать много аргументов если method(Object... args), напр. String.format()
Когда создаете имя метода, помните и об аргументах. Название глагол, аргументы - существительное. К глаголу можно добавить доп сущ-е, чтобы раскрыть аргумент. writeField(String name)
Когда создаете и даете название функции, есть опасность, что она выполняет действия, которые не описаны: побочный эффект. В функции checkPassword() происходит инициализация сессии, что не описано.
Избегайте функций, параметры которых будут изменены и отданы наружу: public void appendFooter(StringBuffer report) - здесь к репорту будует добавлен футер.
Пусть функция меняет состояние своего владельца: report.appendFooter().
Функция должна что-то делать или отвечать на какой-то вопрос, но не одновременно.
Когда функция возвращает код ошибки (ок не ок), то нужно громозить ифы и элзы. [стр. 71]
Лучше испольщовать исключения.
В блоке try если много когда - лучше вынести в отдельную функцию [стр. 72].
Избегайте дублирования. Если видите повторяющийся код - создавайте функцию, которая будет использована в двух местах.
Многие типы программирования и были созданы, чтобы избежать дублирования.
Эдгар Дейкстра считает, что у функции может быть только один return. Но автор говорит, что можно использовать много, если так лучше будет читаться код.
Автор сначала пишет грязный код. Потом пишет тесты. А потом причесывает согдано своей книги, да так, чтобы тесты проходили. И в итоге у него чистый код.


 - 4. Комментарии, 79 -

Не комментируйте плохой код - перепишите его.
Если вам нужно написать комментарий - значит вы потерпели неудачу в коде. То есть ли у вас получился запутанный код, в котором сложно разобраться, то вы захотите сделать комментарий. А надо просто изменить код, чтобы он стал понятным.
Комментарии лгут, потому что код изменяется, а программистам лень изменгять комменатрии.
Стр. 81 - можно создать функцию, которая назвается так же, что вы написали в комментарии.
Хорошие комментарии:
1. Юридические комментарии.
Вставляется в начало каждого исходного файла, насчёт авторских прав. (стр. 82)
2. Информативные комментарии.
Иногда можно давать комментарий, что делает функция, но лучше её переименовать так, чтобы было понятно.
3. Представление намерений.
Автор в комментарии указывает, что он пытается сделать.
4. Пояснение.
Если код очень сложный, но он выражает что-то простое, то можно сделать комментарий. (стр. 83)
5. Предупреждайте о последствиях.
Например если тест долговыполняется, или объекты не синхронизированы.
6. Комментарии TODO.
// TODO - и записываете, что надо будет сделать
7. Усиление.
Сделать акцент на маленькой детали, но которая очень важна.
8. Комментарии Javadoc в общедоступных API.
Плохие комментарии:
1. Бормотание.
Не оставляйте комментарий, который понятен только вам. Или, что вы вернётесь к нему чтобы исправить, но забудете.
2. Избыточные комментарии.
Не пишите комментарии, которые и так понятны по коду.
3. Недостоверные комментраии.
Комментарий может вводить в заблеждение, потому что то что делает код, может рассказать только код.
4. Обязательные комментарии.
Автор говорит, что по Javadoc все функции должны быть закомментированы. Но он говорит, что это - монстр и не надо так делать. (стр. 90)
5. Журнальные комментарии.
Раньше, до появления SVC, в начале каждого файла делались журнальные комменатрии вносимых изменений.
6. Шум.
Случаи. когда комментарий бесполезен. Напр. // конструктор по умолчанию. (примеры - стр. 92)
7. Опасный шум.
Например когда копипастишь, то забудешь изменить код на правильный.
8. Старайтесь делать такой код, который был бы понятен без комменатрия.
9. Позиционнеы маркеры.
Используйте заголовки, когда встречаются редко. Потому что, когда они встречаются часто, прогер воспринимает их как шум.
10. Иногда мы используем комменатрии за закрывающимися фигурными скобками, чтобы знать, какая функция завершилась. Но лучше тогда делать так, чтобы функции были короче.
11. До появления SVC писали комментарий, кто написал этот код.
12. Не оставляйте закомментированный код. У нас есть SVC.
13. Комментарии HTML. Комментируйте html-код с помощью IDE, а не звёздочками.
14. Не пишите на локальном уровне комментарий, который отвечает за глобальное пояснение.
15. Слишком много информации.
Не пишите в комменатрий исторический выкладки и так далее.
16. Неочевидные комментарии.
Комментарий должен объяснять код. Плохо когда сам комментарий нуждется в объеснении. (стр.97)
17. Если вы всё объяснили в Javadoc перед функцией, то не надо объяснять каждую строчку кода. (стр.98)
-
Если вы собираетесь написать комментарий, значит вы потерпели неудачу.
Остановитесь и подумайте, можно ли написать код, чтобы было понятно.
Программисты меняют код, но не меняют комментарий, поэтому часто комментарии лгут.
Можно написать функцию, которая делает и назвается так же как и ваш комментарий [стр. 81]
Допустимы комментарии в начале файле с лицензией, копирайтом и т.д.
Комментарий уместен, чтобы привести пример какого-нибудь формата. Нпример формат даты в регулярном выражении.
Можете комментировать код, если используете стороннюю библиотеку [стр. 84].
Можете комментировать, чтобы предупредить других о возможных последствих [стр. 85].
Можно оставлять TODO, если это нельзя сделать прямо сейчас (ждёте релиза и т.д.).
Можно оставить комментарий, если маленький элемент очень важен. И чтобы его не снесли после следующего рефакторинга.
Если пишет API для общего пользования, то комментарии Javadoc обязательны.
Боьшинство комментариев - плохие. Это подпорка для некачественного кода либо мысли вслух программиста.
На [стр. 86] комментарий без кода, и нам непонятно, настройки по умолчанию уже были загружены, или автор вообще забыл доавить код. Это комментарий на скорую руку. Если уж пишите комментарий - то хорошо обдумывайте.
Избыточные комментарии - когда комментарий просто повторяет код [стр. 87].
К тому же этот комментарий недостоверный.
Автор говорит, что не обязатально для каждой функции писать комментарий. Они только загромождяют код, когда из нзвания функций и параметров и так всё понятно.
Журнальные комментарии [стр. 90] - не понял.
Не пишите комментарий над методом, который нормально назван и так понятно что он делает.
Если вы пишите комментарий, и вам уже надоело их писать - форматируйте код [стр. 92]
Если много вложенных функций или идет одна за одной - уберите комментарий и разнесите логику в несколько строк [стр. 93]
Если комментарий - это заголовок перед чередой сходных функций, не делайте это часто, а то превратится в шум.
Некоторые любят комментировать закрывающие фигурные скобки. Лучше форматируйте.
Не надо в комментарии писать, кто добавил код. Гит сам хранит.
Не оставляйте заккоментированный код.
В комментариях не оставляйте html код, чтобы сделать javadoc красивее.
В комментариях не указывайте нелокальную информацию.
Не пиши в комментарии документацию - укажи ссылку.
Плохо, когда нужно смотреть код, чтобы понять комментарий.
Короткая функция с хорошим названием лучше любого комментария.
Не используйте javadoc для внутренних функций - только для API.
[стр. 98] - пример форматирования.


 - 5. Форматирование, 102 -

Когда чувак видит ваш проект он думает: "Если код такой неаккуратный, значит и все остальные аспекты сделаны хоть бы как."
Выберите правила форматирования и придерживайтесь их.
Код надо писать чисто ещё и потому, чтобы потом можно было хорошо добавлять и изменять.
Стр. 104 - красивый рисунок, сколько строк в каждом файле разных программ.
Газетная метафора. Файла должны быть похожи на газетную статью: сначал заголовок. Потом крактое содержание. И так - сверу вниз с увеличением подробностей.
Package, import, class и методы надо разделять пустыми строками.
Между классом и полями не нужно пустой строки. Между полями и методами - пустая строка.
То есть строки, между которыми есть тесная связь, должны быть сжаты по вертикали.
Концепции, тесно связанные друг с другом, должны находиться поблизости друг от друга по вертикали.
Переменные следует объявлять как можно ближе к месту использования.
Переменные, управляющие циклом - объявлять внутри цикла. (стр. 108)
Переменные эксземпляров - объявляются в начале класса.
Самая старшая функция должна быть вверху. А те функции, которые вызываются старшей - внизу. (Нисходящий порядок)
Когда у функций концептуальное родство - они должны быть рядом. (Например группа функций выполняет аналогичные операции)
Автор не имеет ничего против строк в 100 и 120 символов, но это вызвано небрежностью программиста.
Горизонтальное форматирование у меня нормально.
Автор советует: return a*a + b*b.
Горизонтальное выравнивание у меня нормально.
Отступы - у меня нормально.
Цикл for надо записывать в три строки со скобкой. 
Если работаете в группе, заранее договаривайтесь, как будете форматировать код.
Стр. 118 - пример чистого кода от автора.
-
Выберите набор правил форматирования, которые будут соблюдать команда.
Вы думаете, что главное - чтобы программа работала. Но когда вам нужно будет менять функиональность, код должен быть удобочитаем, сопровождаемым, расширяемым.
Исходный файл должен выглядеть как газетная статья: заголовок, краткое содержание и вниз с подробностями.
Имени файла должно быть достаточно, чтобы понять, что в нём находится.
Отделяйте пустыми строками логические блоки.
Если объекты похожи - наоборот, соединяйте. Например переменные класса; поля класса и т.п.
Если две концепции тесно связаны -- должны идти один под одним, чтобы не круить вниз-вверх.
Переменные обьявлять как можно ближе к использованию.
Переменные экземпляров - в начале класса.
Если одна функция вызывает другую - должны идти сверху вниз.
Если функции очень похожи (assertTrue, asertFalse) - то тоже надо рядом держать.
- Горизонтальное форматирование (112)
Авор установил 120 символов.
Автор не ставит пробелы со знаком умножения.
Автор отказался от выравнивания полей класса по горизонтали.
Использует левые отступы. Не пишет ифы или методы в одну строчку.
while без кода (117)
Для одного проекта все разрабы должны придерживаться единого стиля форматирования.


 - 6. Объекты и структуры данных, 121 -

Стр. 122-123. Непонятно. Надо не просто делать поля приватные и доступ через геттеры-сеттеры, а надо делать абстракцию.
Структура данных - это только поля. Объект - это приватные поля и методы доступа к ним. В книге пример с фигурами.
Процедурный код (код, использующий структуры данных) позволяет легко добавлять новые функции без изменения существующих структур данных. ОО код упрощает добавление новых классов без изменения существующих функций.
Не обязательно всегда использовать ООП. Иногда лучше структуры данных и процедуры.
Закон Деметры - модуль не должен знать внутреннее устройство тех объектов, с которыми работает.(Если Вы хотите, чтобы собака побежала, глупо командовать её лапами, лучше отдать команду собаке, а она уже разберётся со своими лапами сама.) (подробно стр. 126)
Крушение поезда - стр. 126 - не понял ничего.
Не используйте гибриды - то есть к классе есть важные функции, а также есть открытые перменные.
Короче стр. 126-128 - непонятно. Может потом разберусь с увеличением опыта.
Что-то про DTO - опять непонятно. Автору не нравятся бины (pojo). 
-
 - Абстракция данных (121)
Автор сетует что сейчас по умолчанию все ставят геттеры, сеттеры.
Скрывать реализацию и делать поля приватными нужно, чтобы создавать абстракции (интерфесы). Пользователь должен работать с Entity, а не с полями.
Пример: координата. Мы должны открыть только сеттер, у которого две переменные сразу (чтобы нельзя было создать координату с одной ординатой)
Пример: двигатель. У него есть поля: объём и уровень топлива. Не надо предоставлять доступ по геттерам. Нужно предоставить метод: getFuleInPercents. (даже если мы внутри поменяем логику, клиенту не нужно будет ничего менять).
Вместо раскрытия структуры - представление данны на абстрактном уровне.
Не надо бездумно лепить геттеры сеттеры
 - Ассиметрия данны/объектов (123)
Структура данных - предоставляет доступ к данным напрямую.
Объект - скрвает данные за абстракциями и методами.
Есть фигуры и класс Shape.
Два подхода.
Процедурный. В фигура мы только задаем данные. А в Shape - метод area, внутри которого используем instanceOf. Если добавм perimeter - нам не нужно менять все фигуры, но придётся опять instanceOf. - Легко добавлять новые методы без изменения классов. Использование структур данных.
ООП. Все фигуры наследуют метод area()
(125 курсив)
 - Закон Деметры (126)
Модуль взамодействет с объектами. И он не должен знать о внутренностях этих объектов.
Нельзя делать так: a.getB().getMethodFromB(); -> лучше разделить по строчкам
Надо разобраться для чего нам из контекста класса a аж вызывать getMethodFromB(). И разбравшись - сделать один метод a.getMethodFromA() который делает то же что и getMethodFromB(). В общем отрефакторить.
DTO - квинтессенция структуры данных. Джава бины - автор считает, что это псевдоинкапсуляция.
Active Records (акивные записи) (129) - соодержат методы save и find. Преобразование таблиц.
Вся суть на стр. 130

 - 7. Обработка ошибок, 130 -

Обработка ошибок важна, но если они заслоняют собой логику программы - значит, она реализована неверно.
Плохой способ: вручную в лог записывать возможные ошибки. Хороший способ: обрабатывать с помощью try-catch/ Dj втором случает рабочий метод и метод по обработке ошибок разделены.
Используя try-catch-finally блок try имеет транзакционную природу.
Если у нас есть иерархия из вложенных друг в друга методов. До обработав ошибку на самом низком уровне, нам придётся добавлять обработку ошибки во всех более высоких уровнях. (объявлять throws NewException) (нарушается инкапсуляция, потому что все уровни долдны знать о проверяемом исключении самого низкого уровня)
В блоке catch передавайте всю полезную информацию. (сведения о сбойной операции, тип сбоя, журналирование)
Если один метод может вызвать много разных ошибок и вы хотите все эти ошибки по отдельности перехватить, то используйте обёртки - стр. 136-137.
Стр. 138 - пойму, когда столкнусь. То есть особый случай берётся не через if, а через try cathc/ В этом случае автор рекомендует использовать паттерн Особый случай (Fowler)
Автор сказал, что когда из метода возвращаем объект, то не надо, чтобы возвращался null. Но что с этим делать он так и не объяснил. Привер только пример для возвращения списка, где в методе инициализируется пустой список: retutn Collections.emptyList() (стр. 140)
Делайте так, чтобы нельзя было передать null в метод в качестве аргумента.
-
Если обработка ошибок разбросана по всему коду - значит логика программы реализована неверно.
Используйте исключения вместо кодов ошибок (132). В первом листинге мы делаем действие, которое возвращает статус. И на основании статуса мы идём дальше. То есть выполнение операции и проверка статсу (ошибки) - а одном уровне.
А надо делать ка в листинге 2. Мы делаем оперцию и просто ловим если что-то произойдет. А исключения бросаются во внутренних методах.
Начните с написания команды try-catch-finally. Если вы думаете, что ваш код может что-то выбросить, сразу же пишите try. Причем try {} - действует как транзакция.
Используйте TDD: сначала тест с exception кейсом, а потом код.

 - 8. Границы, 142 -

Часто приходится использовать сторонний код (библиотеки).
Если мы (как библитека) вернем клиенту Map, то он может вызвать .clear(), оят нам хочется запретить это делать.
Вместо Map надо возваращать Map<Sensor> (не нужно будет приводить после get). Но и в эом случае, если в Java изменится релизация Map, то нам нужно будет контролировать все sensors.get(sensorId).
А если сделаь как на (144) то getById всегда будет одинаково, а если что-то ппроизойдёт с Map, то нам нужно будет поменять только в одном месте.
Автор не рекомендует возвращать Map и сунуть Map в параметры в API.
Если вы не уверены в стороннем API, можно написать тесты (BeckTDD).

145